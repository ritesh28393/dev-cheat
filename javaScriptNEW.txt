intro
	inheritance is possible using prototype. By default every object has prototype property which can be used to attach methods and other properties
	javascript is a single threaded ie no 2 script can run simultaneously. Ajax allow script to continue execution while waiting for some information ie do not block execution
	
object creation
	factory pattern
		var personFactory = function(name, age, state){
			var temp = {};
			temp.name = name;
			temp.age = age;
			temp.state = state;
			temp.printPerson = function(){
				console.log(this.name + ' ' + this.age + ' ' + this.state);
			}
			return temp;
		}
		var person1 = personFactory('John', 32, 'CA');
		var person2 = personFactory('Kie', 25, 'NJ');
	constructor pattern
		based on 'function is another object'
		use 'new' keyword to create object
		drawback - each instance has the copy of every method defined inside the function
		example
			var personConstructor = function(name, age, state){
				this.name = name;
				this.age = age;
				this.state = state;
				this.printPerson = function(){
					console.log(this.name + ' ' + this.age + ' ' + this.state);
				}
			}
			var person1 = new personConstructor('John', 32, 'CA');
			var person2 = new personConstructor('Kie', 25, 'NJ');
	prototype pattern
		this approach do not have properties or methods attached to the created object
		example
			var personPrototype = function(){};
			personPrototype.prototype.name = 'no name';  // or personPrototype.name = 'no name';
			personPrototype.prototype.age = 0;
			personPrototype.prototype.state = 'no state';
			personPrototype.prototype.printPerson = function(){
				console.log(this.name + ' ' + this.age + ' ' + this.state);
			}
			var person1 = new personPrototype();
			person1.name = 'John';
			person1.age = 32;
			person1.state = 'CA';
		'name' in person1 // return true. checks whether 'name' property is present in person1. If it does not find there, javaScript checks in the parent object and its prototype
		person1.hasOwnProperty('name') // return true. Checks only in the person1
	dynamic prototype pattern
		every properties and methods are defined inside the function
		example
			var personDynamicPrototype = function(name, age, state){
				this.name = name;
				this.age = age;
				this.state = state;
				if(typeof this.printPerson != 'function'){
					personDynamicPrototype.prototype.printPerson = function(){
						console.log(this.name + ' ' + this.age + ' ' + this.state);
					}
				}
			}
			var person1 = new personDynamicPrototype('John', 32, 'CA');
		
callback function
	function can be passed as a parameter
	example
		function add(x, y){return x+y}
		function multiply(x, y){return x*y}
		function calc(x,y,callback){return callback(x,y)}
		console.log(calc(3,5,add));  // =>8
		console.log(calc(3,5,multiply));  // =>15
		
anonymous function
	function calc(x,y,callback){
		if(typeof callback === 'function'){
			return callback(x,y)
		}
	}
	console.log(calc(3,5,function(a,b){return a+b}));  // =>8
	console.log(calc(3,5,function(a,b){return a*b}));  // =>15
	
call, apply and bind
	independent function with 'this' keyword
		var addToThis = function(a, b, c){
			return this.num + a + b + c;
		}		
	call - addToThis.call({num:10}, 1, 2 , 3)  // =>16
	apply - addToThis.apply({num:10}, [1, 2 , 3])  // =>16. This takes array as second parameter
	bind 
		return a function after binding the object with the addToThis()
		var bound = addToThis.bind({num:10});
		//console.dir(bound);
		bound(1, 2, 3)
		
Q&A
	difference between 'var' and 'let' keywords
		let introduced in ECMAscript 6
		let has a block scope while var has function scope
		var gets hoisted while let don't
	difference between == and ===
		both compare operator. object is compared as reference
		== compares only value while === compares both value and typeof
	difference between 'let' and 'const'
		const can't be reassigned
		const object can be modified but can't be reassigned
	difference between null and undefined
		both defines empty value
		when declaring varible, undefined is automatically assigned
		typeof null === 'object' and typeof undefined === 'undefined'
	arrow function
		alias of anonymous function
		example 'without arrow'
			const profile = {
				name: 'no name',
				setName: function(name){
					let myWindowFunction = function(n){
						this.name = n;
					}
					myWindowFunction(name);
				}
			}
			profile.setName('John');
			console.log(window.name);  // =>'John'
			console.log(profile.name);  // =>'no name'
		example 'with arrow'
			const profile = {
				name: 'no name',
				setName: function(name){
					let myArrowFunction = (n) => {
						this.name = n;
					}
					myArrowFunction(name);
				}
			}
			profile.setName('John');
			console.log(window.name);  // =>'John'
			console.log(profile.name);  // =>'John'
	difference between function declaration and function expression
		function funcD(){//function declaration}  and   let funcE = function(){//function expression}
		function declaration is hoisted while expression not
	setTimeout
		the call back function get execurted only when other commands in the stack are executed
		example
			setTimeout(function(){console.log('a')},0);
			console.log('b');
			console.log('c');
			setTimeout(function(){console.log('a')},0);
			console.log('b');
			console.log('c');
			// output => b c b c a a
	
		
	
	
		
	
