intro
	inheritance is possible using prototype. By default every object has prototype property which can be used to attach methods and other properties
	javaScript is a single threaded ie no 2 script can run simultaneously. 
	Ajax allow script to continue execution while waiting for some information ie do not block execution
	closure - function with preserved data
	function(...n){//n is an array}
	
Promises
	simple example
		declaring promise
			let promiseToCleanRoom = new Promise(function(resolve,reject){
				let isCleaned = true;
				// cleaning the room
				if(isCleaned)
					resolve('is cleaned');
				else
					reject('is not cleaned');
			});
		calling promise
			promiseToCleanRoom.then(function(fromResolve){
				console.log('the room ' + fromResolve);
			}).catch(function(fromReject){
				console.log('the room ' + fromReject);
			});
	nested example
		let cleanRoom = function() {
			return new Promise(function(resolve, reject) {
				resolve('Cleaned Room');
			});
		};
		let removeGarbage = function(message) {
			return new Promise(function(resolve, reject) {
				resolve(message + ' Removed Garbage');
			});
		};
		let winIcecream = function(message) {
			return new Promise(function(resolve, reject) {
				resolve( message + ' Won Ice-cream');
			});
		};
		// calling chain of promises
		cleanRoom().then(function(result){
			return removeGarbage(result);
		}).then(function(result){
			return winIcecream(result);
		}).then(function(result){
			console.log('finished ' + result);
		});
		// output => finished Cleaned Room Removed Garbage Won Ice-cream
	Promise.all([promise1, promise2, ...]) - returns a promise with array of values
		Promise.all([cleanRoom(), removeGarbage(), winIcecream()]) // output => ["Cleaned Room", "undefined Removed Garbage", "undefined Won Ice-cream"]
	Promise.race([promise1, promise2, ...]) - returns any one promise which finishes first
		Promise.race([cleanRoom(), removeGarbage(), winIcecream()]) // output => Cleaned Room"
	
object creation
	factory pattern
		var personFactory = function(name, age, state){
			var temp = {};
			temp.name = name;
			temp.age = age;
			temp.state = state;
			temp.printPerson = function(){
				console.log(this.name + ' ' + this.age + ' ' + this.state);
			}
			return temp;
		}
		var person1 = personFactory('John', 32, 'CA');
		var person2 = personFactory('Kie', 25, 'NJ');
	constructor pattern
		based on 'function is another object'
		use 'new' keyword to create object
		drawback - each instance has the copy of every method defined inside the function
		example
			var personConstructor = function(name, age, state){
				this.name = name;
				this.age = age;
				this.state = state;
				this.printPerson = function(){
					console.log(this.name + ' ' + this.age + ' ' + this.state);
				}
			}
			var person1 = new personConstructor('John', 32, 'CA');
			var person2 = new personConstructor('Kie', 25, 'NJ');
	prototype pattern
		this approach do not have properties or methods attached to the created object
		example
			var personPrototype = function(){};
			personPrototype.prototype.name = 'no name';  // or personPrototype.name = 'no name';
			personPrototype.prototype.age = 0;
			personPrototype.prototype.state = 'no state';
			personPrototype.prototype.printPerson = function(){
				console.log(this.name + ' ' + this.age + ' ' + this.state);
			}
			var person1 = new personPrototype();
			person1.name = 'John';
			person1.age = 32;
			person1.state = 'CA';
		'name' in person1 // return true. checks whether 'name' property is present in person1. If it does not find there, javaScript checks in the parent object and its prototype
		person1.hasOwnProperty('name') // return true. Checks only in the person1
	dynamic prototype pattern
		every properties and methods are defined inside the function
		example
			var personDynamicPrototype = function(name, age, state){
				this.name = name;
				this.age = age;
				this.state = state;
				if(typeof this.printPerson != 'function'){
					personDynamicPrototype.prototype.printPerson = function(){
						console.log(this.name + ' ' + this.age + ' ' + this.state);
					}
				}
			}
			var person1 = new personDynamicPrototype('John', 32, 'CA');
		
callback function
	function can be passed as a parameter
	example
		function add(x, y){return x+y}
		function multiply(x, y){return x*y}
		function calc(x,y,callback){return callback(x,y)}
		console.log(calc(3,5,add));  // =>8
		console.log(calc(3,5,multiply));  // =>15
		
anonymous function
	function calc(x,y,callback){
		if(typeof callback === 'function'){
			return callback(x,y)
		}
	}
	console.log(calc(3,5,function(a,b){return a+b}));  // =>8
	console.log(calc(3,5,function(a,b){return a*b}));  // =>15
	
function chaining
	simple example
		var obj = function(){   
			this.i = 0;  
			this.add = function(i){
				this.i += i;
				return this;
			};
			this.substract = function(i){
				this.i -= i;
				return this;
			};
			this.print = function(){console.log(this.i);};   
		};
		var x = new obj();
		x.add(3).substract(2).substract(2).print();
	using closure
		var obj = function(){   
			var i = 0;  // i is private property
			var add = function(j){
				i += j;
				return this;
			};
			var substract = function(j){
				i -= j;
				return this;
			};
			var print = function(){console.log(i);};   
			return { add:add, substract:substract, print:print};   
		};
		var x = new obj();
		x.add(3).substract(2).substract(2).print();
		
immediately invoked function expression(IIFE)
	syntax - 
		(function(parameter){})(argument)
		(function(parameter){}(argument))
		!function(parameter){}(argument)
		-function(parameter){}(argument)
	makes the parameters as private
	helps in providing closure
		var counter = (function(){
			var i=0;
			return{
				get:function(){return i},
				set:function(value){i=value},
				increment:function(){i++}
			}
		})();
		console.log(counter.get())  // 0
		console.log(counter.set(5))
		console.log(counter.increment())
		console.log(counter.get())  // 6
	
call, apply and bind
	independent function with 'this' keyword
		var addToThis = function(a, b, c){
			return this.num + a + b + c;
		}		
	call - addToThis.call({num:10}, 1, 2 , 3)  // =>16
	apply - addToThis.apply({num:10}, [1, 2 , 3])  // =>16. This takes array as second parameter
	bind 
		return a function after binding the object with the addToThis()
		var bound = addToThis.bind({num:10});
		//console.dir(bound);
		bound(1, 2, 3)
		
Q&A
	difference between 'var' and 'let' keywords
		let introduced in ECMAscript 6
		let has a block scope while var has function scope
		var gets hoisted while let don't
	difference between == and ===
		both compare operator. object is compared as reference
		== compares only value while === compares both value and typeof
	difference between 'let' and 'const'
		const can't be reassigned
		const object can be modified but can't be reassigned
	difference between null and undefined
		both defines empty value
		when declaring variable, undefined is automatically assigned
		typeof null === 'object' and typeof undefined === 'undefined'
	arrow function
		alias of anonymous function
		example 'without arrow'
			const profile = {
				name: 'no name',
				setName: function(name){
					let myWindowFunction = function(n){
						this.name = n;
					}
					myWindowFunction(name);
				}
			}
			profile.setName('John');
			console.log(window.name);  // =>'John'
			console.log(profile.name);  // =>'no name'
		example 'with arrow'
			const profile = {
				name: 'no name',
				setName: function(name){
					let myArrowFunction = (n) => {
						this.name = n;
					}
					myArrowFunction(name);
				}
			}
			profile.setName('John');
			console.log(window.name);  // =>'John'
			console.log(profile.name);  // =>'John'
	difference between function declaration and function expression
		function funcD(){//function declaration}  and   let funcE = function(){//function expression}
		function declaration is hoisted while expression not
	setTimeout
		the call back function get executed only when other commands in the stack are executed
		example
			setTimeout(function(){console.log('a')},0);
			console.log('b');
			console.log('c');
			setTimeout(function(){console.log('a')},0);
			console.log('b');
			console.log('c');
			// output => b c b c a a

events
	bubbles event property returns a Boolean value that indicates whether or not an event is a bubbling event.
	cancelBubble() - 
		this method prevents the event-flow from bubbling up to parent elements.
		to prevent both bubbling up to parent elements and capturing down to child elements, use the stopPropagation() method instead.
	stopPropagation() - 
		this method prevents propagation of the same event from being called.
		propagation means bubbling up to parent elements or capturing down to child elements.
	stopImmediatePropagation() - When clicking on a button, execute the first event handler, and stop the rest of the event handlers from being executed
	currentTarget event property returns the element whose event listeners triggered the event
	target event property returns the element that triggered the event.
	eventPhase event property 
		returns a number that indicates which phase of the event flow is currently being evaluated.
		The number is represented by 4 constants:
			0. NONE
			1. CAPTURING_PHASE - The event flow is in capturing phase
			2. AT_TARGET - The event flow is in target phase, i.e. it is being evaluated at the event target
			3. BUBBLING_PHASE - The event flow is in bubbling phase
	isTrusted event property 
		returns a Boolean value indicating whether the event is trusted or not.
		In Chrome, Firefox and Opera, the event is trusted if it is invoked by the user, and not trusted if it is invoked by a script. 
		In IE, all events are trusted except those that are created with the createEvent() method.
	preventDefault() method 
		cancels the event if it is cancelable, meaning that the default action that belongs to the event will not occur
		does not prevent further propagation of an event through the DOM. Use the stopPropagation() method to handle this.
